# Firs of all, we created a SSH key. For that, we typed the next command in terminal:
ssh-keygen -t ed25519 -C "yaird0910@gmail.com
# We copied the SSH key with the next command:
pbcopy <  ~/.ssh/id_ed25519.pub
# And we added a new KEY in GitHub.com

### INITIAL SETUP ###
# Set the right Name and Email to the global configuration
git config --global --edit
#type this on Terminal
git config --global user.name "Yair Diaz"
git config --global user.email yaird0910@gmail.com

#To set main as the default branch name do:
$ git config --global init.defaultBranch main

## Cambiar la rama por defecto de git a main (recomendado)
# Para hacer esto (justo después del git init y ANTES del ```git add`), estando en tu repositorio desde la terminal debes escribir el siguiente comando:
git checkout -b main
# Esto establecerá tu rama por defecto como main y no tendrás problemas al subir tu código al repositorio.

# Rename the current branch "master" to default branch of GitHub (main)
git branch -m master main

# Set the default text editor, in this case Visual Studio Code
git config --global core.editor "code --wait"

# Checking Your Settings
git config --list   git config --list --show-origin    

#### CREATE A NEW REPOSITORY ######
# We address to the folder we want to create a repository
# create a new repisitory:
git init
# Add all files in that folder:
git add .
# Make the commit:
git commit -m "Initial state"


### CREATE THE REMOTE REPOSITORY IN GITHUB ####
# We address to github.com, create a new repository and copy the SSH connection:
git@github.com:yaird0910/RM.git
# On the Terminal we type the next command to add a new remote repository:
git remote add origin git@github.com:yaird0910/RM.git 
# Make sure everything is OK:
git remote -v
# Result:
origin	git@github.com:yaird0910/RM.git (fetch)
origin	git@github.com:yaird0910/RM.git (push)


# Upload the changes made to our local repository to the remote repository:
git push -f origin main

### Updating changes in our existing repository:
git add .
git commit -m "Second commit, the file git_first_steps.git was added"
# git commit -am  //is an alternative to git add and commit
git push -f origin main


### INFO FROM GITHUB
#…or create a new repository on the command line
echo "# RM" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin git@github.com:yaird0910/RM.git
git push -u origin main
#…or push an existing repository from the command line
git remote add origin git@github.com:yaird0910/RM.git
git branch -M main
git push -u origin main


### COURSE PLATZI GIT AND GITHUB
# to show the status and which files were added and which ones don't
git status
# to show evere change we have done, and more detailes
git show
# to show the log of changes from a file
git log (<file_name>)
git log --stat
# to compare the differences between two versions(two commits) of a file
# you can find the commits' ID's with the command git log <file_name>
git diff (<id_commitA> <id_commitB>)

# to revoke the action of add | to remove the file from staging or even from Hard Disk
git rm --cached <file_name> 
git rm --force <file_name>

# to check a previous version of a file or branch
git checkout <id_commit> <file_name>
git checkout main <file_name>

#to go back to a previous version of a branch
git reset <id_commit> --hard

### STATES OF OUR PROJECT ###
## ------------------- Working directory --- Staging area --- Git repository
# touch, create,etc.-->
# remove, delete <-----
#                           git add----------->
#                                   <--------git rm -cached
#                                   <--------git rm -force
#                                            git commit--------->
#                                                    <---------git reset -soft
#                               <------------------------------git reset -mixed
#   <----------------------------------------------------------git reset -hard


# Este comando nos ayuda a eliminar archivos de Git sin eliminar su historial del sistema de versiones
git rm --cached: Elimina los archivos del área de Staging y del próximo commit pero los mantiene en nuestro disco duro.
git rm --force: Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder al registro de la existencia de los archivos, de modo que podremos recuperarlos si es necesario (pero debemos usar comandos más avanzados).

# Este comando nos ayuda a volver en el tiempo. Pero no como git checkout que nos deja ir, mirar, pasear y volver. Con git reset volvemos al pasado sin la posibilidad de volver al futuro. Borramos la historia y la debemos sobreescribir. No hay vuelta atrás.
git reset --soft: Borramos todo el historial y los registros de Git pero guardamos los cambios que tengamos en Staging, así podemos aplicar las últimas actualizaciones a un nuevo commit.
git reset --hard: Borra todo. Todo todito, absolutamente todo. Toda la información de los commits y del área de staging se borra del historial.


### commands to GitHub (Remote server)
git clone url_del_servidor_remoto: Nos permite descargar los archivos de la última versión de la rama principal y todo el historial de cambios en la carpeta .git.
git push: Luego de hacer git add y git commit debemos ejecutar este comando para mandar los cambios al servidor remoto.
git fetch: Lo usamos para traer actualizaciones del servidor remoto y guardarlas en nuestro repositorio local (en caso de que hayan, por supuesto).
git merge: También usamos el comando git merge con servidores remotos. Lo necesitamos para combinar los últimos cambios del servidor remoto y nuestro directorio de trabajo.
git pull: Básicamente, git fetch y git merge al mismo tiempo.

## A further explanation about git log ##
# Algunos comandos que pueden ayudar cuando colaboren con proyectos muy grandes de github:

git log --oneline - Te muestra el id commit y el título del commit.
git log --decorate- Te muestra donde se encuentra el head point en el log.
git log --stat - Explica el número de líneas que se cambiaron brevemente.
git log -p- Explica el número de líneas que se cambiaron y te muestra que se cambió en el contenido.
git shortlog - Indica que commits ha realizado un usuario, mostrando el usuario y el titulo de sus commits.
git log --graph --oneline --decorate y
git log --pretty=format:"%cn hizo un commit %h el dia %cd" - Muestra mensajes personalizados de los commits.
git log -3 - Limitamos el número de commits.
git log --after=“2018-1-2” ,
git log --after=“today” y
git log --after=“2018-1-2” --before=“today” - Commits para localizar por fechas.
git log --author=“Name Author” - Commits realizados por autor que cumplan exactamente con el nombre.
git log --grep=“INVIE” - Busca los commits que cumplan tal cual está escrito entre las comillas.
git log --grep=“INVIE” –i- Busca los commits que cumplan sin importar mayúsculas o minúsculas.
git log – index.html- Busca los commits en un archivo en específico.
git log -S “Por contenido”- Buscar los commits con el contenido dentro del archivo.
git log > log.txt - guardar los logs en un archivo txt


### Usage of Branches ###

# to list all branches
git branch
# Add a new branch from the current branch
git branch <name_branch>
# to change to another branch
git checkout <name_branch>
# this command is a fusion between branch and checkout (create a new branch and change to that one)
git checkout -b <name_branch>

## To merge 2 branches ##
# *Before make the marge make sure you're in 'main' branch. In that way 
# you're going to marge the another branch with 'main', and 'main' 
# is still going to be the MAIN branch. Otherwise, the another branch is
# going to be the MAIN branch*

# Steps:
git checkout main   -> to move to the main branch
git merge <name_branch> -> to merge the another branch with main
git log  (--graph)  -> to check the last commits after mergings

# Check extention GIT Graph 
# When you have a conflict you need to fix it manually in your text editor
# Recuerda que siempre debemos crear un nuevo commit para aplicar los cambios del merge. Si Git puede resolver el conflicto hará commit automáticamente. Pero, en caso de no pueda resolverlo, debemos solucionarlo y hacer el commit.
# Los archivos con conflictos por el comando git merge entran en un nuevo estado que conocemos como Unmerged. Funcionan muy parecido a los archivos en estado Unstaged, algo así como un estado intermedio entre Untracked y Unstaged, solo debemos ejecutar git add para pasarlos al área de staging y git commit para aplicar los cambios en el repositorio.